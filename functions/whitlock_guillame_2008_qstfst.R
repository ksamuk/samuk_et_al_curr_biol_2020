#########################    qstfst.parboot    ########################## Returns the bootstrap estimates of Qst - Fst under neutrality following the procedure# described in Whitlock & Guillaume (2009). Also returns the bootstrap estimates of Fst# and Qst used to compute the null distribution.## @params:# fst.dat : per-locus components of variance of the neutral markers; each line is a locus,#           columns are the coefficients `a', `b', and `c' from Weir & Cockerham 1984.# qst.dat : input table of the crossing data; column names must be `pop', `sire', `dam', #           and `trait' (i.e. breeding values). The three first must be transformed into#           factors first (using the `factor' function) to be able to extract the #           components of variance. This table can be omitted if the next one is given.# qst.MS  : Mean Squares of the phenotypic trait, can be omitted if `qst.dat' is present.#           This argument is a list object that must be identical to the output of the#           `MeanSq' function below.# ndeme   : # of populations in the sample# nloci   : optional, # of neutral loci to sample from the input table, will be set to the #           # of rows if `fst.dat' if missing. Can be used to sample a smaller number of loci.# nboot   : # of bootstrap replicates to perform## @output:# Returns a list with the following values:# Est, Est.stdev, Est.CI: the mean, standard deviation, and confidence interval of #                         the bootstrap estimates of Qst - Fst# Fst, Fst.stdev, Fst.CI: the mean, standard deviation, and confidence interval of#                         the bootstrap estimates of Fst# Qst, Qst.stdev, Qst.CI: the mean, standard deviation, and confidence interval of#                         the bootstrap estimates of Qstqstfst.parboot = function(fst.dat, qst.dat, qst.MS=NULL, ndeme, nloci=NULL, nboot=1000){  if(missing(qst.MS) && missing(qst.dat))     stop("Both \"qst.dat\" and \"qst.MS\" are missing in input, you must provide at least one.")    #get the mean squares of the quantitative trait, if not given in input  if(missing(qst.MS)) qst.MS = MeanSq(qst.dat)    #check for the number of neutral loci to sample from  if(missing(nloci))  nloci = nrow(fst.dat)  else if(nloci > nrow(fst.dat)) {     warning("nloci is greater than the number of loci in the Fst table, resetting to nrow(fst.dat).")     nloci = nrow(fst.dat)  }    #initializing  #the observed Fst:  fst.obs = sum(fst.dat[,1])/sum(fst.dat[,1] + fst.dat[,2] + fst.dat[,3])    boot.est = vector(length = nboot)  qst.est  = vector(length = nboot)  fst.est  = vector(length = nboot)    #bootstrapping  for(i in 1:nboot) {    #1. Fst bootstrap replicate; sample nloci from the neutral markers, with replacement    fst.repl = fst.sample(fst.dat, nloci)    #2. get a bootstrap replicate of Qst using the parametric bootstrap    qst.repl = qst.parboot(qst.MS, fst.obs)    #3. get the bootstrap replicate of Qst - Fst, and store it    boot.est[i] = qst.repl - fst.repl    #store values    fst.est[i] = fst.repl    qst.est[i] = qst.repl  }    #return a list of values:  return(list(    #distribution and CI of the bootstrap estimates:    Est       = mean(boot.est, na.rm=TRUE),    Est.stdev = sd(boot.est, na.rm=TRUE),    Est.CI    = quantile(boot.est,c(0.025,0.975), na.rm=TRUE),    #the bootstrap estimates of Fst and Qst:    Fst       = mean(fst.est, na.rm=TRUE),    Fst.stdev = sd(fst.est, na.rm=TRUE),    Fst.CI    = quantile(fst.est,c(0.025,0.975), na.rm=TRUE),    Qst       = mean(qst.est, na.rm=TRUE),    Qst.stdev = sd(qst.est, na.rm=TRUE),    Qst.CI    = quantile(qst.est,c(0.025,0.975), na.rm=TRUE) ))}#########################    qst.parboot    ########################## returns a Qst pseudovalue from the parametric bootstrap based on the MS# data of the crosses dataset (i.e. 3 levels; pop, sire, and dam)# @params:#  - MS : the output list from the MeanSq() function below#  - meanFst: the observed value of the multilocus Fst# This code is modified from O'Hara & Merila 2005.qst.parboot = function(MS, meanFst) {		vp = ( 8*MS$N*MS$MS[3]*meanFst + MS$MS[2]*(meanFst*(1-8*MS$N)-1) )/(meanFst-1)    VarP = vp*rchisq(1, MS$df[1])/MS$df[1] #pop    VarS = MS$MS[2]*rchisq(1, MS$df[2])/MS$df[2] #sire    VarD = MS$MS[3]*rchisq(1, MS$df[3])/MS$df[3] #dam    Ratio = MS$N*(VarS - VarD)/(VarP - VarS)    return( 1/(1 + 8*Ratio) )}#########################       MeanSq      ########################## computes the Mean Squares of the crosses data, thus expects the dataset# to be composed of three _factor_ columns (`pop', `sire', `dam') and # one column containing the phenotype/breeding value (`trait').# Note that each sire and each dam must have different identifiers.# Modified from O'Hara & Merila 2005.MeanSq = function(dat) {  SumSq = function(data, groupB, groupW) {    xx = tapply(data, list(groupW, groupB), mean, simplify=TRUE)    mean.xx = apply( xx, 2, mean, na.rm = TRUE)    sum(sweep(data.frame(xx),2,mean.xx)^2, na.rm = TRUE)*length(data)/nlevels(groupW)  }  pop.SS  = SumSq(dat$trait, factor(rep(1,length(dat$pop))), dat$pop)  sire.SS = SumSq(dat$trait, dat$pop, dat$sire)  dam.SS  = SumSq(dat$trait, dat$sire, dat$dam)  pop.df  = nlevels(dat$pop)-1  sire.df = nlevels(dat$sire)-nlevels(dat$pop)  dam.df  = nlevels(dat$dam)-nlevels(dat$sire)  MS      = c(pop.SS/pop.df, sire.SS/sire.df, dam.SS/dam.df)  df      = c(pop.df, sire.df, dam.df)  N.sire  = nlevels(dat$sire)/nlevels(dat$pop)    return(list(MS=MS, df=df, N=N.sire))}#########################        fst.sample       ########################## returns the Fst value computed on a sample of the loci given in input# @param:#  - obs:  a table containing the components of variance for each locus#          the table must have one line per locus and at least 3 columns corresponding#          to the three coefficient a, b, and c as defined in Weir&Cockerham 1984##  - nloci: the size of the sample (i.e. num of loci to draw from the table)## Note: the components of variance are those given by the Weir&Cockerham 1984 # method. They can be generated by the software Nemo using FSTAT files as input files.# Nemo can be found at http://nemo2.sourceforge.net.fst.sample = function(obs, nloci) {  loc.smpl = sample(1:nloci,size=nloci,replace=TRUE)  #select the sampled loci from the input table:  dat  = obs[loc.smpl,]  # Fst = a/(a+b+c); from Weir&Cockerham 1984  return( sum(dat[,1])/sum(dat[,1]+dat[,2]+dat[,3]) )}